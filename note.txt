全量追踪的性能问题 - 追踪所有模块会导致性能急剧下降

白名单模块不存在的处理 - addInstrumentedModule 会返回 false，需要处理

内存加载的 so（如加壳、动态解密） - 这些 so 不在 /proc/maps中以文件形式存在，需要特殊处理


QBDI 是动态二进制插桩，每条指令都要经过 JIT 翻译
全量追踪意味着所有代码（包括 libc、linker、ART 等）都被插桩

只要是普通 Android app（有 Java/Kotlin 代码），libart.so 一定会被加载。

只捕获可执行段代码。
 因为 QBDI 的“插桩范围”本质上是要被翻译/执行的指令地址范围（代码区），不是“要监控
  的数据地址范围”。所以通常只加带 x 权限的可执行段，避免把纯数据页当成代码处理。

  全局变量/只读常量能不能捕捉，关键看它们是否被已插桩的代码通过内存访问指令读写：

  - 能：全局 .data/.bss、只读 .rodata（literal pool/常量表）只要被 ldr/str 这类指令
    访问，你的 addMemAccessCB 里会看到 a.accessAddress 指向那些数据地址。
  - 不能：如果“硬编码”是指令立即数（比如 mov w0, #0x1234），这不是内存访问，所以不
    会出现在内存访问回调里；要抓这种需要看指令操作数（InstAnalysis 的 operands/反汇
    编），而不是 MemoryAccess。



› 每次回调都取符号信息很慢  虽然慢但是信息够全面吧


• 对，“每次回调都取符号”确实能让日志更“可读”，但不等于“信息全面”：

  - 你拿到的 moduleName/symbolName/offset 只描述当前指令地址属于哪个函数（代码侧符
    号），并不告诉你 accessAddress 对应哪个全局变量/哪段 .rodata（数据侧符号要另外
    做地址→ELF 符号解析）。
  - 很多场景符号本来就不全：库被 strip、内联、PLT/Thunk、JIT/匿名映射（尤其 ART/
    JIT）都会让 symbolName 为空或不准。
  - 性能瓶颈通常不止符号化，fprintf 每次内存访问一行更容易直接把你卡在 I/O 上。

  更常用的折中：运行时只记录“原始地址 + module + offset”（快、信息不丢），事后用
  llvm-symbolizer/addr2line 离线符号化；或对 instAddress 做缓存/只对命中的模块或采
  样再取符号。
